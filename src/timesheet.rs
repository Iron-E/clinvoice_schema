mod default;
mod display;
mod exchange;
mod restorable_serde;

use std::sync::OnceLock;

use chrono::{DateTime, Utc};
use money2::{Decimal, Money};
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

use super::{Employee, Expense, Id, Job};
use crate::{DateTimeExt, IncrementResult};

/// A [`Timesheet`] contains information about continuous periods of work on a [`Job`].
///
/// A [`Job`] may contain multiple [`Timesheet`]s, with different and/or duplicate
/// `employee`s.
#[cfg_attr(feature = "serde", derive(Deserialize, Serialize))]
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Timesheet
{
	/// The reference number of this [`Timesheet`], which is unique among all [`Timesheet`]s.
	///
	/// Should be generated by a database, and never altered once assigned.
	pub id: Id,

	/// The [`Employee`] who performed this work. If multiple [`Employee`]s collaborated on the
	/// work, they should create separate [`Timesheet`]s.
	pub employee: Employee,

	/// Business-related, non-[hourly-rate](super::Invoice)-related [`Expense`]s which were
	/// incurred during this time.
	pub expenses: Vec<Expense>,

	/// The [`Job`] which was worked on.
	pub job: Job,

	/// The time which this period of work began.
	pub time_begin: DateTime<Utc>,

	/// The time which this period of work ended. If the period of work is ongoing, then this field
	/// will be [`None`].
	pub time_end: Option<DateTime<Utc>>,

	/// A summary of what work was performed.
	///
	/// Markup support (if any) is dependent on the Winvoice frontend.
	pub work_notes: String,
}

impl Timesheet
{
	/// Increment the `time_begin` and `time_begin` according to the `job`'s `increment` field. If
	/// the `time_end` is undefined, it will default to the `time_begin`.
	pub fn increment(&self) -> IncrementResult<(DateTime<Utc>, DateTime<Utc>)>
	{
		self.time_begin.increment_with(self.time_end.unwrap_or(self.time_begin), self.job.increment)
	}

	/// Get the amount of [`Money`] which is owed by the [client](crate::Organization) for work done
	/// on this [`Timesheet`].
	///
	/// `exchange_rates` may be [`None`] in the case that the [hourly rate](super::Invoice) is in
	/// the same [`Currency`] as _every one_ of the `expenses` on this [`Timesheet`].
	///
	/// # Panics
	///
	/// When [`Money::add_assign`] does.
	///
	/// # Examples
	///
	/// ```rust
	/// use core::time::Duration;
	/// use winvoice_schema::{chrono::Utc, Currency, Expense, Job, Money, Timesheet};
	/// # use pretty_assertions::assert_eq;
	///
	/// let job = Job {increment: Duration::from_secs(1800), ..Default::default()};
	/// let timesheets = [
	///   Timesheet {
	///     time_begin: Utc::today().and_hms_opt(2, 0, 0).unwrap(),
	///     time_end: Some(Utc::today().and_hms_opt(2, 22, 0).unwrap()),
	///     job: job.clone(),
	///     ..Default::default()
	///   },
	///   Timesheet {
	///     expenses: vec![Expense {
	///       cost: Money::new(20_00, 2, Currency::Usd),
	///       ..Default::default()
	///     }],
	///     time_begin: Utc::today().and_hms_opt(3, 0, 0).unwrap(),
	///     time_end: Some(Utc::today().and_hms_opt(3, 30, 0).unwrap()),
	///     job: job.clone(),
	///     ..Default::default()
	///   },
	/// ];
	///
	/// assert_eq!(
	///   Timesheet::total_all(&timesheets, Money::new(20_00, 2, Currency::Usd)).unwrap(),
	///   Money::new(4000, 2, Currency::Usd),
	/// );
	/// ```
	///
	/// ```rust,should_panic
	/// # use winvoice_schema::{chrono::Utc, Currency, Expense, Money, Timesheet};
	/// # use pretty_assertions::assert_eq;
	/// #
	/// # let timesheets = [
	/// #   Timesheet {
	/// #     time_begin: Utc::today().and_hms_opt(2, 0, 0).unwrap(),
	/// #     time_end: Some(Utc::today().and_hms_opt(2, 30, 0).unwrap()),
	/// #     ..Default::default()
	/// #   },
	/// #   Timesheet {
	/// #     expenses: vec![Expense {
	/// #       cost: Money::new(20_00, 2, Currency::Usd),
	/// #       ..Default::default()
	/// #     }],
	/// #     time_begin: Utc::today().and_hms_opt(3, 0, 0).unwrap(),
	/// #     time_end: Some(Utc::today().and_hms_opt(3, 30, 0).unwrap()),
	/// #     ..Default::default()
	/// #   },
	/// # ];
	/// let _ = Timesheet::total_all(&timesheets, Money::new(20_00, 2, Currency::Eur));
	/// ```
	pub fn total_all(timesheets: &[Self], hourly_rate: Money) -> IncrementResult<Money>
	{
		static SECONDS_PER_HOUR: OnceLock<Decimal> = OnceLock::new();

		let mut total = Money::new(0, 0, hourly_rate.currency);
		timesheets.iter().filter(|timesheet| timesheet.time_end.is_some()).try_for_each(|timesheet| {
			let (start, end) = timesheet.increment()?;
			total.amount += hourly_rate.amount *
				(Decimal::from(end.signed_duration_since(start).num_seconds()) /
					SECONDS_PER_HOUR.get_or_init(|| 3600.into()));

			timesheet.expenses.iter().for_each(|expense| total += expense.cost);
			IncrementResult::Ok(())
		})?;

		total.amount.rescale(2);
		Ok(total)
	}
}
