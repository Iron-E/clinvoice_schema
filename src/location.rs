mod display;
mod restorable_serde;

use money2::Currency;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

use super::Id;

/// A place in the real world where other parts of the schema can reside.
#[cfg_attr(feature = "serde", derive(Deserialize, Serialize))]
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Location
{
	/// The currency used in this location. If [`None`], it will inherit the `currency` value of
	/// the nearest `outer` [`Location`].
	pub currency: Option<Currency>,

	/// The reference number of this [`Location`], which is unique among all [`Location`]s.
	///
	/// Should be generated by a database, and never altered once assigned.
	pub id: Id,

	/// The name of the [`Location`].
	pub name: String,

	/// The [`Location`] which immediately surrounds this one, such that when `outer` is [`None`],
	/// this [`Location`] must be at the outermost scope which is relevant to the
	/// [`Organization`](super::Organization) using Winvoice.
	pub outer: Option<Box<Self>>,
}

impl Location
{
	/// The currency used in this location, or the [default](Currency::default) if none was
	/// specified.
	pub fn currency(&self) -> Currency
	{
		self.currency.unwrap_or_else(|| self.outer.as_ref().map_or_else(Default::default, |o| o.currency()))
	}
}

#[cfg(test)]
mod tests
{
	use pretty_assertions::{assert_eq, assert_ne};

	use super::{Currency, Location};

	#[test]
	fn currency()
	{
		let earth = Location { ..Default::default() };

		// assert currency defaults
		assert_eq!(earth.currency(), Currency::default());

		let usd = Currency::Usd;
		let usa = Location { currency: usd.into(), outer: Some(earth.clone().into()), ..Default::default() };

		assert_eq!(usa.currency(), usd);

		let arizona = Location { outer: Some(usa.clone().into()), ..Default::default() };

		// assert inherits outer currency
		assert_eq!(arizona.currency(), usa.currency());

		let europe =
			Location { currency: Currency::Eur.into(), outer: Some(earth.clone().into()), ..Default::default() };

		let gbp = Currency::Gbp;
		let britain = Location { currency: gbp.into(), outer: Some(europe.clone().into()), ..Default::default() };

		// assert overrides outer currency
		assert_eq!(britain.currency(), gbp);
		assert_ne!(britain.currency(), europe.currency());
	}
}
